{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.date = void 0;\nconst Schema_1 = require(\"../../Schema\");\nconst getErrorMessageForIncorrectType_1 = require(\"../../utils/getErrorMessageForIncorrectType\");\nconst maybeSkipValidation_1 = require(\"../../utils/maybeSkipValidation\");\nconst schema_utils_1 = require(\"../schema-utils\");\n// https://stackoverflow.com/questions/12756159/regex-and-iso8601-formatted-datetime\nconst ISO_8601_REGEX = /^([+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T\\s]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24:?00)([.,]\\d+(?!:))?)?(\\17[0-5]\\d([.,]\\d+)?)?([zZ]|([+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$/;\nfunction date() {\n  const baseSchema = {\n    parse: (raw, {\n      breadcrumbsPrefix = []\n    } = {}) => {\n      if (typeof raw !== \"string\") {\n        return {\n          ok: false,\n          errors: [{\n            path: breadcrumbsPrefix,\n            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(raw, \"string\")\n          }]\n        };\n      }\n      if (!ISO_8601_REGEX.test(raw)) {\n        return {\n          ok: false,\n          errors: [{\n            path: breadcrumbsPrefix,\n            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(raw, \"ISO 8601 date string\")\n          }]\n        };\n      }\n      return {\n        ok: true,\n        value: new Date(raw)\n      };\n    },\n    json: (date, {\n      breadcrumbsPrefix = []\n    } = {}) => {\n      if (date instanceof Date) {\n        return {\n          ok: true,\n          value: date.toISOString()\n        };\n      } else {\n        return {\n          ok: false,\n          errors: [{\n            path: breadcrumbsPrefix,\n            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(date, \"Date object\")\n          }]\n        };\n      }\n    },\n    getType: () => Schema_1.SchemaType.DATE\n  };\n  return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));\n}\nexports.date = date;","map":{"version":3,"names":["Object","defineProperty","exports","value","date","Schema_1","require","getErrorMessageForIncorrectType_1","maybeSkipValidation_1","schema_utils_1","ISO_8601_REGEX","baseSchema","parse","raw","breadcrumbsPrefix","ok","errors","path","message","getErrorMessageForIncorrectType","test","Date","json","toISOString","getType","SchemaType","DATE","assign","maybeSkipValidation","getSchemaUtils"],"sources":["D:/projects/InterviewCoachWeb/node_modules/cohere-ai/core/schemas/builders/date/date.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.date = void 0;\nconst Schema_1 = require(\"../../Schema\");\nconst getErrorMessageForIncorrectType_1 = require(\"../../utils/getErrorMessageForIncorrectType\");\nconst maybeSkipValidation_1 = require(\"../../utils/maybeSkipValidation\");\nconst schema_utils_1 = require(\"../schema-utils\");\n// https://stackoverflow.com/questions/12756159/regex-and-iso8601-formatted-datetime\nconst ISO_8601_REGEX = /^([+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T\\s]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24:?00)([.,]\\d+(?!:))?)?(\\17[0-5]\\d([.,]\\d+)?)?([zZ]|([+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$/;\nfunction date() {\n    const baseSchema = {\n        parse: (raw, { breadcrumbsPrefix = [] } = {}) => {\n            if (typeof raw !== \"string\") {\n                return {\n                    ok: false,\n                    errors: [\n                        {\n                            path: breadcrumbsPrefix,\n                            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(raw, \"string\"),\n                        },\n                    ],\n                };\n            }\n            if (!ISO_8601_REGEX.test(raw)) {\n                return {\n                    ok: false,\n                    errors: [\n                        {\n                            path: breadcrumbsPrefix,\n                            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(raw, \"ISO 8601 date string\"),\n                        },\n                    ],\n                };\n            }\n            return {\n                ok: true,\n                value: new Date(raw),\n            };\n        },\n        json: (date, { breadcrumbsPrefix = [] } = {}) => {\n            if (date instanceof Date) {\n                return {\n                    ok: true,\n                    value: date.toISOString(),\n                };\n            }\n            else {\n                return {\n                    ok: false,\n                    errors: [\n                        {\n                            path: breadcrumbsPrefix,\n                            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(date, \"Date object\"),\n                        },\n                    ],\n                };\n            }\n        },\n        getType: () => Schema_1.SchemaType.DATE,\n    };\n    return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));\n}\nexports.date = date;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,IAAI,GAAG,KAAK,CAAC;AACrB,MAAMC,QAAQ,GAAGC,OAAO,CAAC,cAAc,CAAC;AACxC,MAAMC,iCAAiC,GAAGD,OAAO,CAAC,6CAA6C,CAAC;AAChG,MAAME,qBAAqB,GAAGF,OAAO,CAAC,iCAAiC,CAAC;AACxE,MAAMG,cAAc,GAAGH,OAAO,CAAC,iBAAiB,CAAC;AACjD;AACA,MAAMI,cAAc,GAAG,wRAAwR;AAC/S,SAASN,IAAIA,CAAA,EAAG;EACZ,MAAMO,UAAU,GAAG;IACfC,KAAK,EAAEA,CAACC,GAAG,EAAE;MAAEC,iBAAiB,GAAG;IAAG,CAAC,GAAG,CAAC,CAAC,KAAK;MAC7C,IAAI,OAAOD,GAAG,KAAK,QAAQ,EAAE;QACzB,OAAO;UACHE,EAAE,EAAE,KAAK;UACTC,MAAM,EAAE,CACJ;YACIC,IAAI,EAAEH,iBAAiB;YACvBI,OAAO,EAAE,CAAC,CAAC,EAAEX,iCAAiC,CAACY,+BAA+B,EAAEN,GAAG,EAAE,QAAQ;UACjG,CAAC;QAET,CAAC;MACL;MACA,IAAI,CAACH,cAAc,CAACU,IAAI,CAACP,GAAG,CAAC,EAAE;QAC3B,OAAO;UACHE,EAAE,EAAE,KAAK;UACTC,MAAM,EAAE,CACJ;YACIC,IAAI,EAAEH,iBAAiB;YACvBI,OAAO,EAAE,CAAC,CAAC,EAAEX,iCAAiC,CAACY,+BAA+B,EAAEN,GAAG,EAAE,sBAAsB;UAC/G,CAAC;QAET,CAAC;MACL;MACA,OAAO;QACHE,EAAE,EAAE,IAAI;QACRZ,KAAK,EAAE,IAAIkB,IAAI,CAACR,GAAG;MACvB,CAAC;IACL,CAAC;IACDS,IAAI,EAAEA,CAAClB,IAAI,EAAE;MAAEU,iBAAiB,GAAG;IAAG,CAAC,GAAG,CAAC,CAAC,KAAK;MAC7C,IAAIV,IAAI,YAAYiB,IAAI,EAAE;QACtB,OAAO;UACHN,EAAE,EAAE,IAAI;UACRZ,KAAK,EAAEC,IAAI,CAACmB,WAAW,CAAC;QAC5B,CAAC;MACL,CAAC,MACI;QACD,OAAO;UACHR,EAAE,EAAE,KAAK;UACTC,MAAM,EAAE,CACJ;YACIC,IAAI,EAAEH,iBAAiB;YACvBI,OAAO,EAAE,CAAC,CAAC,EAAEX,iCAAiC,CAACY,+BAA+B,EAAEf,IAAI,EAAE,aAAa;UACvG,CAAC;QAET,CAAC;MACL;IACJ,CAAC;IACDoB,OAAO,EAAEA,CAAA,KAAMnB,QAAQ,CAACoB,UAAU,CAACC;EACvC,CAAC;EACD,OAAO1B,MAAM,CAAC2B,MAAM,CAAC3B,MAAM,CAAC2B,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEnB,qBAAqB,CAACoB,mBAAmB,EAAEjB,UAAU,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEF,cAAc,CAACoB,cAAc,EAAElB,UAAU,CAAC,CAAC;AACvJ;AACAT,OAAO,CAACE,IAAI,GAAGA,IAAI"},"metadata":{},"sourceType":"script","externalDependencies":[]}