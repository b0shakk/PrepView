{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transform = exports.optional = exports.getSchemaUtils = void 0;\nconst Schema_1 = require(\"../../Schema\");\nconst JsonError_1 = require(\"./JsonError\");\nconst ParseError_1 = require(\"./ParseError\");\nfunction getSchemaUtils(schema) {\n  return {\n    optional: () => optional(schema),\n    transform: transformer => transform(schema, transformer),\n    parseOrThrow: (raw, opts) => __awaiter(this, void 0, void 0, function* () {\n      const parsed = yield schema.parse(raw, opts);\n      if (parsed.ok) {\n        return parsed.value;\n      }\n      throw new ParseError_1.ParseError(parsed.errors);\n    }),\n    jsonOrThrow: (parsed, opts) => __awaiter(this, void 0, void 0, function* () {\n      const raw = yield schema.json(parsed, opts);\n      if (raw.ok) {\n        return raw.value;\n      }\n      throw new JsonError_1.JsonError(raw.errors);\n    })\n  };\n}\nexports.getSchemaUtils = getSchemaUtils;\n/**\n * schema utils are defined in one file to resolve issues with circular imports\n */\nfunction optional(schema) {\n  const baseSchema = {\n    parse: (raw, opts) => {\n      if (raw == null) {\n        return {\n          ok: true,\n          value: undefined\n        };\n      }\n      return schema.parse(raw, opts);\n    },\n    json: (parsed, opts) => {\n      if (parsed == null) {\n        return {\n          ok: true,\n          value: null\n        };\n      }\n      return schema.json(parsed, opts);\n    },\n    getType: () => Schema_1.SchemaType.OPTIONAL\n  };\n  return Object.assign(Object.assign({}, baseSchema), getSchemaUtils(baseSchema));\n}\nexports.optional = optional;\nfunction transform(schema, transformer) {\n  const baseSchema = {\n    parse: (raw, opts) => __awaiter(this, void 0, void 0, function* () {\n      const parsed = yield schema.parse(raw, opts);\n      if (!parsed.ok) {\n        return parsed;\n      }\n      return {\n        ok: true,\n        value: transformer.transform(parsed.value)\n      };\n    }),\n    json: (transformed, opts) => __awaiter(this, void 0, void 0, function* () {\n      const parsed = yield transformer.untransform(transformed);\n      return schema.json(parsed, opts);\n    }),\n    getType: () => schema.getType()\n  };\n  return Object.assign(Object.assign({}, baseSchema), getSchemaUtils(baseSchema));\n}\nexports.transform = transform;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","transform","optional","getSchemaUtils","Schema_1","require","JsonError_1","ParseError_1","schema","transformer","parseOrThrow","raw","opts","parsed","parse","ok","ParseError","errors","jsonOrThrow","json","JsonError","baseSchema","undefined","getType","SchemaType","OPTIONAL","assign","transformed","untransform"],"sources":["D:/projects/InterviewCoachWeb/node_modules/cohere-ai/core/schemas/builders/schema-utils/getSchemaUtils.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.transform = exports.optional = exports.getSchemaUtils = void 0;\nconst Schema_1 = require(\"../../Schema\");\nconst JsonError_1 = require(\"./JsonError\");\nconst ParseError_1 = require(\"./ParseError\");\nfunction getSchemaUtils(schema) {\n    return {\n        optional: () => optional(schema),\n        transform: (transformer) => transform(schema, transformer),\n        parseOrThrow: (raw, opts) => __awaiter(this, void 0, void 0, function* () {\n            const parsed = yield schema.parse(raw, opts);\n            if (parsed.ok) {\n                return parsed.value;\n            }\n            throw new ParseError_1.ParseError(parsed.errors);\n        }),\n        jsonOrThrow: (parsed, opts) => __awaiter(this, void 0, void 0, function* () {\n            const raw = yield schema.json(parsed, opts);\n            if (raw.ok) {\n                return raw.value;\n            }\n            throw new JsonError_1.JsonError(raw.errors);\n        }),\n    };\n}\nexports.getSchemaUtils = getSchemaUtils;\n/**\n * schema utils are defined in one file to resolve issues with circular imports\n */\nfunction optional(schema) {\n    const baseSchema = {\n        parse: (raw, opts) => {\n            if (raw == null) {\n                return {\n                    ok: true,\n                    value: undefined,\n                };\n            }\n            return schema.parse(raw, opts);\n        },\n        json: (parsed, opts) => {\n            if (parsed == null) {\n                return {\n                    ok: true,\n                    value: null,\n                };\n            }\n            return schema.json(parsed, opts);\n        },\n        getType: () => Schema_1.SchemaType.OPTIONAL,\n    };\n    return Object.assign(Object.assign({}, baseSchema), getSchemaUtils(baseSchema));\n}\nexports.optional = optional;\nfunction transform(schema, transformer) {\n    const baseSchema = {\n        parse: (raw, opts) => __awaiter(this, void 0, void 0, function* () {\n            const parsed = yield schema.parse(raw, opts);\n            if (!parsed.ok) {\n                return parsed;\n            }\n            return {\n                ok: true,\n                value: transformer.transform(parsed.value),\n            };\n        }),\n        json: (transformed, opts) => __awaiter(this, void 0, void 0, function* () {\n            const parsed = yield transformer.untransform(transformed);\n            return schema.json(parsed, opts);\n        }),\n        getType: () => schema.getType(),\n    };\n    return Object.assign(Object.assign({}, baseSchema), getSchemaUtils(baseSchema));\n}\nexports.transform = transform;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}